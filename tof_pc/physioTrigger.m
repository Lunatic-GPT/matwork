function [ph,trig,hr]=physioTrigger(data,minInterval,TR,nphase,trig_delay,thr,plot_results,fakePeaks,Peaks2MON,realPeaks)
% [ph,trig]=physioTrigger(data,minInterval,TR,plot_results)
% data: physiology signal
% minInterval: unit: s; the minimum spacing between peaks
% TR: unit: s
% nphase: number of phases to divide each cardiac cycle into
% trig_delay: number of time points to shift the trig for defining the
% phase intervals.  Can be non-integer.
% thr: peaks intervals outside (mean+-thr* std of the cardiac cycle standard
% deviation) will be removed if >0.  if thr=0, not used.

% fakePeaks, realPeaks, Peaks2MON - indices of data correspond to the fake
% peaks to remove, real peaks to add, peaks between which a new peak will
% be added.

%output:
%ph: phase indices for each physio signal time point: 1 to nphase
% trig: peak positions for the physio signal

data=double(data);
if ~exist('realPeaks','var')
    realPeaks= [];
end

if ~exist('fakePeaks','var')
    fakePeaks= [];
end

if ~exist('Peaks2MON','var')
    Peaks2MON= [];
end

if ~exist('plot_results','var')
    plot_results=false;
end

nTRmin=round(minInterval/TR);

[mx_orig,mn]=peakdet(data,100);

if mx_orig(1,1)==1
    mx_orig(1,:)=[];
end


[mx,imx]=setdiff(mx_orig(:,1),fakePeaks);
mx(:,2)=mx_orig(imx,2);

ffakePeaks=setdiff(fakePeaks,mx_orig(:,1));

if length(ffakePeaks)>0
    fprintf('Some fake peaks not detected\n');
    disp(ffakePeaks);
end


%%
ind_rm=[];
for i=1:length(realPeaks)
    interval=round(mx(:,1)-realPeaks(i))*TR;
    ind_tmp=find(abs(interval)<minInterval & abs(interval)~=0);
    ind_rm(end+1:end+length(ind_tmp))=ind_tmp; 
end
mx(ind_rm,:)=[];


while 1
interval=diff(mx(:,1));

i2=find(interval<nTRmin);

ind_rm=[];
j=1;

while j<=length(i2)
   
    if i2(j)==1
        
        if   mx(1,1)==1  %the first peak is a fake peak
            ind_rm(end+1)=1;
        end
        j=j+1;
    
    else
        
 %old method; works in HVB320 and HVB319; but not in HVB321      
%         if interval(i2(j)-1)<interval(i2(j)+1)  % the following interval is normal
%             ind_rm(end+1)=i2(j);
%         else         % the previous interval is normal; 
%                      %if a fake peak is present, in_rm generated by the two conditions may overlap
%             ind_rm(end+1)=i2(j)+1;
%         end
        
       if j<length(i2) && i2(j)+1 ==i2(j+1) % the next interval also too short, then combine the two; 
           
           ind_rm(end+1)=i2(j)+1;
           
           j=j+2;
       else  % only itself is too short
            ind_rm(end+1)=i2(j)+1;
           
           j=j+1;
       end
    end
    
end
mx(ind_rm,:)=[];
if isempty(ind_rm)
    break;
end

end

interval2=diff(mx(:,1));

interval2_old=interval2;
sd=std(interval2);

mn=mean(interval2);
% automatically determine threshold for outlier detection.
% thr=sd*3.4;
% 
% while 1
%     ind_outlier=find(abs(interval2-mn)>thr);
%     
%     if isempty(ind_outlier)
%         break;
%     end
%     
%     if thr<sd
%         error('Error fixing the physio outlier peaks');
%         
%     end
%     
%     
%     if mod(length(ind_outlier),2)==1 || any(ind_outlier(1:2:end-1)~=ind_outlier(2:2:end)-1)
%         
%         thr=thr-0.1*sd;
%         continue;
%     end
%     
%     break;
%     
% end
if thr>0
thr=thr*sd;
ind_outlier=find(abs(interval2-mn)>thr);
i=1;

ind_rm=[];
while i<length(ind_outlier)
    
    if ind_outlier(i+1)==ind_outlier(i)+1  % there is a fake peak or noisy peak
        if sign(interval2(ind_outlier(i))-mn)*sign(interval2(ind_outlier(i+1))-mn)==-1  % one peak position was off
            interval_tmp=interval2(ind_outlier(i))+interval2(ind_outlier(i+1));
            interval2(ind_outlier(i))=round(0.5*interval_tmp);
            interval2(ind_outlier(i)+1)=interval_tmp-interval2(ind_outlier(i));  
           
        elseif sign(interval2(ind_outlier(i))-mn)==-1 && sign(interval2(ind_outlier(i+1))-mn)==-1% combine two peaks into one; one peak was fake
            
            interval2(ind_outlier(i+1))=interval2(ind_outlier(i))+interval2(ind_outlier(i+1));
            
            ind_rm(end+1)=ind_outlier(i);
        else
            warning('Not sure what to do');
        end    
    
         i=i+2;
    elseif interval2(ind_outlier(i))>mn % there is arrhythmia
        
        i=i+1;
    else
        warning('This should not happen');
    end
end

else
   ind_rm=[]; 
end
interval2(ind_rm)=[];


mx2=mx;
mx2(ind_rm,:)=[];
mx2(2:end,1)=cumsum(interval2)+mx2(1,1);  % final except MON peaks;

mx3=cat(1,mx2,[Peaks2MON,data(Peaks2MON)]);  % intermediate

mx3=unique(mx3,'rows');
mx4=mx3;

[tmpPeaks,imx4]=intersect(mx4(:,1),Peaks2MON);

mx4(imx4,1)=round((mx4(imx4+1,1)+mx4(imx4-1,1))/2);
mx4(imx4,2)=data(mx4(imx4,1));  %all final peaks
trig=mx4(:,1);
ph = getIndexPhysioSignalPC(trig,length(data),nphase,trig_delay);

fprintf('percent of interval less than phase number %d - %f\n',nphase,sum(diff(trig)<nphase*2)/length(trig));


%%
if plot_results
    %%
  
    tt=length(data);
    nseg=ceil(tt*TR/30);
    
    clr=jet(nphase);
    
    [peak_real,imx2]=intersect(mx2(:,1),mx_orig(:,1));
    peak_real(:,2)=mx2(imx2,2);
    
    [peak_real_adjust,imx4]=setdiff(mx4(:,1),mx2(:,1));
    peak_real_adjust(:,2)=mx4(imx4,2);
    
    [peak_fake,imx]=setdiff(mx_orig(:,1),mx2(:,1));
    peak_fake(:,2)=mx_orig(imx,2);
    
    for i=1:nseg
        
      h=figure;%   subplot(3,ceil(nseg/3),i);
        t_thr1=tt/nseg*(i-1);
        t_thr2=tt/nseg*i;
        
        
        t=(1:length(data));
        ind=find(t<=t_thr2&t>t_thr1);
        
%         for j=1:length(ind)
%           plot(t(ind(j)),data(ind(j)),'.','Color',clr(ph(ind(j)),:));
%           hold on;
%         end
        
      plot(t(ind),data(ind),'k.');
      
        hold on;
        ind=peak_real(:,1)<=t_thr2&peak_real(:,1)>t_thr1;
         ind3=peak_real_adjust(:,1)<=t_thr2&peak_real_adjust(:,1)>t_thr1;
         
        ind2=peak_fake(:,1)<=t_thr2&peak_fake(:,1)>t_thr1;
        
      hp1=  plot(peak_real(ind,1),peak_real(ind,2),'ob','MarkerSize',4);
       hp2= plot(peak_fake(ind2,1),peak_fake(ind2,2),'*b','MarkerSize',4);
       hp3= plot(peak_real_adjust(ind3,1),peak_real_adjust(ind3,2),'or','MarkerSize',4);
       
      hp=hp1;
      lbl={'Real'};
      
      if ~isempty(hp2)
          hp(end+1)=hp2;
          lbl{end+1}='Fake';
      end
      
      if ~isempty(hp3)
          hp(end+1)=hp3;
          lbl{end+1}='MON';
      end
      
       legend(hp,lbl);
       
       
        xlabel('Time (s)');
        xlim([t_thr1,t_thr2]);
        
      set(h,'Position', [165         463        1475         420]);
      drawnow;
    end
 figure;
 
      interval4=diff(mx4(:,1));
        plot(mx4(2:end,1),interval4*TR,'ro-');
        hold on;
   %     plot(mx(2:end,1)*TR,interval2_old*TR,'bo-');
        
        plot([1,length(data)],[mn-thr,mn-thr]*TR,'k-');
        
        plot([1,length(data)],[mn+thr,mn+thr]*TR,'k-');
        
        xlabel('Time (TR)');
        xlim([0,length(data)]);
        ylabel('Interval (s)');
        
        title(sprintf('Heart Rate = %3.1f/min',60/(mean(interval4)*TR)));

        hr=60/(mean(interval4)*TR);
end


function ph = getIndexPhysioSignalPC(trig,npts,nphase,trig_delay)
 
% trig: indices for peaks; should be between 1 and npts 
% npts: number of physio signal time points
% nphase: number of phases to divide each cardiac cycle into

ph=zeros(1,npts);
trig=trig+trig_delay;
for i=1:npts
 
    itr=find(i>=trig(1:end-1)&i<trig(2:end));
    
  
    if isempty(itr)
        if i<trig(1) %before first peak
      
            trig0=2*trig(1)-trig(2);
            
          ph(i)=round((i-trig0)/(trig(2)-trig(1))*nphase);
          
        else  %after last peak
        
           if round((npts-trig(end))/(trig(end)-trig(end-1))*nphase)>nphase % too long
               ph(i)=round((i-trig(end))/(npts-trig(end))*nphase);
           else
             ph(i)=round((i-trig(end))/(trig(end)-trig(end-1))*nphase);
           end
        end
    else
      
        ph(i)=round((i-trig(itr))/(trig(itr+1)-trig(itr))*nphase);
        
    end
    
end

ph(ph==0)=nphase;
for i=1:nphase
    fprintf('Phase %d = %d\n',i,sum(ph==i));
end




